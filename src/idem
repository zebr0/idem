#!/usr/bin/python3 -u

import datetime
import hashlib
import os.path
import subprocess
import sys
import time
import urllib.error
import urllib.request

import zebr0


# formats given time in a human-readable way
def strformat(time): return datetime.datetime.fromtimestamp(time).strftime("%c")


# turns given text in blue
def blue(string): return "\033[94m" + string + "\033[0m"


# turns given text in green
def green(string): return "\033[92m" + string + "\033[0m"


# turns given text in red
def red(string): return "\033[91m" + string + "\033[0m"


# returns the full path of an idem file
def get_full_path(file): return os.path.join(idem_path, file)


# returns the mtime of an idem file
def get_mtime(file): return os.path.getmtime(get_full_path(file))


# represents a command about to be executed
class Command:
    def __init__(self, command):
        # the command itself
        self._command = command

        # its md5 hash
        self._hash = hashlib.md5(self._command.encode("ascii")).hexdigest()

        # is it always supposed to be run ?
        self._always_run = any(filter(lambda a: a in self._command, always_run))

    # has the command ever been run before ?
    def _todo(self):
        return not os.path.isfile(get_full_path(self._hash))

    # creates an idem file to mark and log the command's execution
    def _write_idem_file(self):
        # creates the file only if the command has to be run just once...
        if not self._always_run:
            with open(get_full_path(self._hash), "w") as file:
                file.writelines(self._command)

    # prints the command's status, whether it will be executed or not
    def dryrun(self):
        print(blue("always") if self._always_run else blue("  todo") if self._todo() else green("  done"), self._command)

    # executes the command if it hasn't been executed yet
    # in "step" mode, asks confirmation before running each step
    # in "retry" mode, should a command fail, waits for a few seconds before trying it again
    def run(self, step, retry):
        if self._always_run or self._todo():
            if step:
                print(blue("next:"), self._command)
                print(blue("(e)xecute,"), green("(s)kip,"), green("always ski(p),"), red("(a)bort ?"))
                choice = sys.stdin.readline().strip()
                if choice == "e":
                    print(blue("executing"))
                elif choice == "s":
                    print(green("skipped"))
                    return
                elif choice == "p":
                    self._write_idem_file()
                    print(green("skipped"))
                    return
                else:
                    print(red("aborting"))
                    exit(0)
            else:
                print(blue("executing"), self._command)

            # initializes the maximum number of times we try to run the command
            tries = (retry_number if retry else 0) + 1
            while tries:
                tries = tries - 1
                # opens a subshell to execute the command, and prints stdout and stderr lines as they come
                sp = subprocess.Popen(self._command, shell=True, stdout=sys.stdout, stderr=sys.stderr)
                sp.wait()
                # if the run is successful...
                if sp.returncode == 0:
                    self._write_idem_file()
                    print(green("done"))
                    return
                elif tries:  # if not, and there's still retries to do, we wait before looping again
                    time.sleep(retry_delay)
                    print(blue("retrying"))
                else:
                    print(red("error"))
                    exit(1)
        else:
            print(green("skipping"), self._command)


# downloads the commands of a given script
# with the "include" directive, can do so recursively
def download_commands(script):
    try:
        # initializes the resulting Commands' list
        commands = []

        # downloads the script and loop through each line
        for line in urllib.request.urlopen("{0}/scripts/{1}".format(base_url, script)).read().decode("ascii").splitlines():
            if line.startswith("##"):  # if the line begins with ##, it may be a directive, so we analyze its words
                split = line.rsplit()
                if split[1] == "include":
                    # include directive: recursively downloads the given script's commands and adds them to the list
                    commands.extend(download_commands(split[2]))
                elif split[1] == "resource":
                    # resource directive: appends a command that downloads the given file into the given directory
                    commands.append(Command("wget {0}/resources/{1}/{2} -O {3}/{2}".format(base_url, script, split[2], split[3])))
            elif not line.startswith("#") and not line == "":
                # it's a standard shell command, appends it to the end of the list
                commands.append(Command(line))

        return commands
    except urllib.error.HTTPError as error:
        print(red("unknown script:"), script) if error.code == 404 else print(red(str(error)))
        exit(1)


# main function: prints a history of all idem executed commands
def show_log():
    if os.path.isdir(idem_path):
        for file_name in sorted(os.listdir(idem_path), key=get_mtime):
            with open(get_full_path(file_name)) as file:
                print(blue(file_name), green(strformat(get_mtime(file_name))), file.read().strip())


# main function: downloads then runs or tests a given script
def run_script():
    # ensures that idem is run as root
    if os.geteuid() != 0:
        print(red("root privileges required to run commands"))
        exit(1)

    # ensures that idem path exists
    if not os.path.isdir(idem_path):
        os.makedirs(idem_path)

    for c in download_commands(args.script):
        c.dryrun() if args.dry else c.run(args.step, args.retry)


argparser = zebr0.ArgumentParser(description="Lightweight Python-Shell framework for idempotent local provisioning.")
subparsers = argparser.add_subparsers()

parser_log = subparsers.add_parser("log", help="prints a history of all executed commands")
parser_log.set_defaults(func=show_log)

parser_run = subparsers.add_parser("run", help="downloads then runs or tests a given script")
parser_run.add_argument("script", help="script identifier in the repository")
parser_run.add_argument("--dry", action="store_true", help="tests the script instead of running it")
parser_run.add_argument("--step", action="store_true", help="asks confirmation before running each step")
parser_run.add_argument("--retry", action="store_true", help="should a command fail, waits for a few seconds before trying it again")
parser_run.set_defaults(func=run_script)

args = argparser.parse_args()
args.func()
