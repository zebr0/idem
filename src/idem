#!/usr/bin/python3 -u

import argparse
import configparser
import datetime
import hashlib
import os.path
import subprocess
import sys
import time
import urllib.request


# formats given time in a human-readable way
def strformat(time): return datetime.datetime.fromtimestamp(time).strftime("%c")


# turns given text in blue
def blue(string): return "\033[94m" + string + "\033[0m"


# turns given text in green
def green(string): return "\033[92m" + string + "\033[0m"


# turns given text in red
def red(string): return "\033[91m" + string + "\033[0m"


# handles idem configuration
class Configuration:
    def __init__(self):
        # reads the configuration file first from /etc then from the working directory if present
        parser = configparser.ConfigParser()
        parser.read(["/etc/idem.conf", "idem.conf"])

        # base url for idem scripts and resources
        self._base_url = parser.get("config", "base_url",
                                    fallback="https://raw.githubusercontent.com/zebr0/idem-files/master")

        # path where the idem files will be stored
        self.idem_path = parser.get("config", "idem_path", fallback="/var/idem")

        # list of commands that will always be run (no idem file will be created for them)
        self.always_run = parser.get("config", "always_run", fallback="apt-get update").split(";")

        # in "retry" mode, the number of retries should a command fail
        self.retry_number = int(parser.get("config", "retry_number", fallback="2"))

        # in "retry" mode, the delay in seconds between each retry
        self.retry_delay = int(parser.get("config", "retry_delay", fallback="4"))

    def get_resource_url(self): return self._base_url + "/resources/{0}/{1}"

    # returns the formatted command to download, for a given script, a given resource in a given directory
    def get_resource_command(self, script, resource, directory):
        return ("wget " + self.get_resource_url() + " -O {2}/{1}").format(script, resource, directory)

    # returns the formatted command to download and parse, for a given script, a given template in a given directory
    def get_template_command(self, script, template, directory):
        return ("wget -O- " + self.get_resource_url() + " | templ > {2}/{1}").format(script, template, directory)

    # returns the url for a given script
    def get_script_url(self, script):
        return (self._base_url + "/scripts/{0}").format(script)

    # returns the full path of an idem file
    def get_full_path(self, file):
        return os.path.join(self.idem_path, file)

    # returns the mtime of an idem file
    def get_mtime(self, file):
        return os.path.getmtime(self.get_full_path(file))


# reads the configuration for the rest of the script
config = Configuration()


# represents a command about to be executed
class Command:
    def __init__(self, command):
        # the command itself
        self._command = command

        # its md5 hash
        self._hash = hashlib.md5(command.encode("ascii")).hexdigest()

        # is it always supposed to be run ?
        self._always_run = any(filter(lambda a: a in self._command, config.always_run))

    # has the command ever been run before ?
    def todo(self):
        return not os.path.isfile(config.get_full_path(self._hash))

    # prints the command's status, whether it will be executed or not
    def dryrun(self):
        print((blue("always") if self._always_run else blue("  todo") if self.todo() else green("  done")),
              self._command)

    # executes the command if it hasn't been executed yet
    # in "step" mode, asks confirmation before running each step
    # in "retry" mode, should a command fail, waits for a few seconds before trying it again
    def run(self, step, retry):
        if self._always_run or self.todo():
            if step:
                print(blue("next:"), self._command)
                print(blue("(e)xecute,"), green("(s)kip,"), green("always ski(p),"), red("(a)bort ?"))

                choice = sys.stdin.readline().strip()
                if choice == "e":
                    print(blue("executing"))
                elif choice == "s":
                    print(green("skipped"))
                    return
                elif choice == "p":
                    self._write_idem_file()
                    print(green("skipped"))
                    return
                else:
                    print(red("aborting"))
                    exit(0)
            else:
                print(blue("executing"), self._command)

            # initializes the maximum number of times we try to run the command
            try_number = 1 + (config.retry_number if retry else 0)
            while try_number:
                try_number = try_number - 1

                # opens a subshell to execute the command, and prints stdout and stderr lines as they come
                sp = subprocess.Popen(self._command, shell=True, stdout=sys.stdout, stderr=sys.stderr)
                sp.wait()

                # if the run is successful...
                if sp.returncode == 0:
                    self._write_idem_file()
                    print(green("done"))
                    return
                elif try_number:  # if not, and there's still retries to do, we wait before looping again
                    time.sleep(config.retry_delay)
                    print(blue("retrying"))
                else:
                    print(red("error"))
                    exit(1)
        else:
            print(green("skipping"), self._command)

    # creates an idem file to mark and log the command's execution
    def _write_idem_file(self):
        # creates the file only if the command has to be run just once...
        if not self._always_run:
            with open(config.get_full_path(self._hash), "w") as file:
                file.writelines(self._command)


# downloads the commands of a given script
# with the "include" directive, can do so recursively
def download_commands(script):
    # initializes the resulting Commands' list
    commands = []

    # downloads the script and loop through each line
    for line in urllib.request.urlopen(config.get_script_url(script)).read().decode("ascii").splitlines():
        # if the line begins with ##, it may be a directive, so we analyze its words
        if line.startswith("##"):
            split = line.rsplit()

            if split[1] == "include":
                # include directive: recursively downloads the given script's commands and adds them to the list
                commands.extend(download_commands(split[2]))
            elif split[1] == "resource":
                # resource directive: appends a command that downloads the given file into the given directory
                commands.append(Command(config.get_resource_command(script, split[2], split[3])))
            elif split[1] == "template":
                # template directive: similar to "resource" except it executes each {{ block }}
                commands.append(Command(config.get_template_command(script, split[2], split[3])))
        elif not line.startswith("#") and not line == "":
            # it's a standard shell command, appends it to the end of the list
            commands.append(Command(line))

    return commands


# main function: prints a history of all idem executed commands
def show_log(args):
    if os.path.isdir(config.idem_path):
        for file_name in sorted(os.listdir(config.idem_path), key=config.get_mtime):
            with open(config.get_full_path(file_name)) as file:
                print(blue(file_name), green(strformat(config.get_mtime(file_name))), file.read().strip())


# main function: downloads then runs or tests a given script
def run_script(args):
    # ensures that idem is run as root
    if os.geteuid() != 0:
        print(red("root privileges required to run commands"))
        exit(1)

    # ensures that idem path exists
    if not os.path.isdir(config.idem_path):
        os.makedirs(config.idem_path)

    for c in download_commands(args.script):
        c.dryrun() if args.dry else c.run(args.step, args.retry)


# main function: helper function to easily set the base url to another github account
def set_base_url_github(args):
    parser = configparser.ConfigParser()

    # if the configuration file already exists, reads its content
    if os.path.isfile(args.filename):
        parser.read(args.filename)
    else:  # if not, creates an empty "config" section
        parser.add_section("config")

    # sets the new base url with the given parameters
    parser.set("config", "base_url",
               "https://raw.githubusercontent.com/{0}/{1}/{2}".format(args.account, args.repository, args.branch))

    # writes/overwrites the configuration file
    with open(args.filename, "w") as file:
        parser.write(file)


# entrypoint
if __name__ == "__main__":
    # argumentparser : the best way to handle program arguments in python
    argparser = argparse.ArgumentParser(
        description="Lightweight Python-Shell framework for idempotent local provisioning.")
    subparsers = argparser.add_subparsers()

    parser_log = subparsers.add_parser("log", help="prints a history of all idem.py executed commands")
    parser_log.set_defaults(func=show_log)

    parser_run = subparsers.add_parser("run", help="downloads then runs or tests a given script")
    parser_run.add_argument("script", help="script identifier in the repository")
    parser_run.add_argument("--dry", action="store_true", help="tests the script instead of running it")
    parser_run.add_argument("--step", action="store_true", help="asks confirmation before running each step")
    parser_run.add_argument("--retry", action="store_true",
                            help="should a command fail, waits for a few seconds before trying it again")
    parser_run.set_defaults(func=run_script)

    parser_github = subparsers.add_parser("github",
                                          help="helper function to easily set the base url to another github account")
    parser_github.add_argument("account", help="github account name")
    parser_github.add_argument("repository", nargs="?", default="idem-files",
                               help="repository name (default: idem-files)")
    parser_github.add_argument("branch", nargs="?", default="master",
                               help="repository branch name (default: master)")
    parser_github.add_argument("filename", nargs="?", default="/etc/idem.conf",
                               help="configuration file to create/update (default: /etc/idem.conf)")
    parser_github.set_defaults(func=set_base_url_github)

    args = argparser.parse_args()
    args.func(args)
