#!/usr/bin/python3 -u

import datetime
import hashlib
import os.path
import pathlib
import subprocess
import sys
import time

import zebr0


# formats given time in a human-readable way
def strformat(time): return datetime.datetime.fromtimestamp(time).strftime("%c")


# turns given text in blue
def blue(string): return "\033[94m" + string + "\033[0m"


# turns given text in green
def green(string): return "\033[92m" + string + "\033[0m"


# turns given text in red
def red(string): return "\033[91m" + string + "\033[0m"


# returns the full path of a history file
def get_full_path(file): return os.path.join(args.directory, file)


# returns the mtime of a history file
def get_mtime(file): return os.path.getmtime(get_full_path(file))


# returns the md5 hash of a command
def md5(command): return hashlib.md5(command.encode("utf-8")).hexdigest()


# returns if a command must always be run
def always_run(command): return any(filter(lambda a: a in command, ["apt-get update", "apt update"]))


# returns if the command has already been run before (i.e. has a history file)
def todo(command): return not os.path.isfile(get_full_path(md5(command)))


# creates a history file to log the command's execution
def write_history_file(command):
    # creates the file only if the command has to be run just once
    if not always_run(command):
        pathlib.Path(get_full_path(md5(command))).write_text(command)


# prints the command's status, whether it will be executed or not
def dryrun(command):
    print(blue("always") if always_run(command) else blue("  todo") if todo(command) else green("  done"), command)


# executes the command if it hasn't been executed yet
# in "step" mode, asks confirmation before running each step
# in "retry" mode, should a command fail, waits for a few seconds before trying it again
def run(command):
    if always_run(command) or todo(command):
        if args.step:
            print(blue("next:"), command)
            print(blue("(e)xecute,"), green("(s)kip,"), green("always ski(p),"), red("(a)bort ?"))

            choice = sys.stdin.readline().strip()
            if choice == "e":
                print(blue("executing"))
            elif choice == "s":
                print(green("skipped"))
                return
            elif choice == "p":  # to always skip a command, we write a history file even if the command hasn't been executed
                write_history_file(command)
                print(green("skipped"))
                return
            else:  # choice "a"
                print(red("aborting"))
                exit(0)
        else:
            print(blue("executing"), command)

        # initializes the maximum number of times we try to run the command
        tries = 4 if args.retry else 1
        while tries:
            tries = tries - 1

            # opens a subshell to execute the command, and prints stdout and stderr lines as they come
            sp = subprocess.Popen(command, shell=True, stdout=sys.stdout, stderr=sys.stderr)
            sp.wait()

            # if the run is successful...
            if sp.returncode == 0:
                write_history_file(command)
                print(green("done"))
                return
            elif tries:  # if not, and there's still retries to do, we wait before looping again
                time.sleep(10)
                print(blue("retrying"))
            else:
                print(red("error"))
                exit(1)
    else:
        print(green("skipping"), command)


# main function: prints a history of all executed commands
def show_history():
    if os.path.isdir(args.directory):
        for filename in sorted(os.listdir(args.directory), key=get_mtime):
            with open(get_full_path(filename)) as file:
                print(blue(filename), green(strformat(get_mtime(filename))), file.read().strip())


# main function: downloads then runs or tests a given script
def run_script():
    # ensures that the program is run as root
    if os.geteuid() != 0:
        print(red("root privileges required to run commands"))
        exit(1)

    # ensures that history path exists
    if not os.path.isdir(args.directory):
        os.makedirs(args.directory)

    for command in zebr0_service.lookup(args.script).splitlines():
        if command and not command.startswith("#"):  # filters out empty lines and comments
            dryrun(command) if args.dry else run(command)


argparser = zebr0.ArgumentParser(description="Lightweight idempotent local provisioning.")
argparser.add_argument("-d", "--directory", nargs="?", default="/var/zebr0/history", help="path to the history files directory (default: /var/zebr0/history)")

subparsers = argparser.add_subparsers()
subparsers.add_parser("history", help="prints a history of all executed commands").set_defaults(func=show_history)

parser_run = subparsers.add_parser("run", help="downloads then runs or tests a given script")
parser_run.add_argument("script", help="script identifier in the repository")
parser_run.add_argument("--dry", action="store_true", help="tests the script instead of running it")
parser_run.add_argument("--step", action="store_true", help="asks confirmation before running each step")
parser_run.add_argument("--retry", action="store_true", help="should a command fail, waits for a few seconds before trying it again")
parser_run.set_defaults(func=run_script)

args = argparser.parse_args()

zebr0_service = zebr0.Service(args)
args.func()
